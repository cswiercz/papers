\documentclass[12pt]{article}

\usepackage{fullpage}

\usepackage{amsmath,amssymb,amsthm}
%\usepackage{verbatim}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={Computing the Riemann Constant Vector},    % title
    pdfauthor={Swierczewski, Patterson, and Deconinck},     % author
    pdfcreator={Swierczewski},   % creator of the document
    pdfkeywords={mathematics} {algebraic geometry} {riemann constant vector} {theta functions} {abel map} {jacobian},
    pdfnewwindow=true,      % links in new window
    colorlinks=false,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}
\renewcommand{\algorithmicrequire}{\textbf{Input:}\,}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%
% custom listings (code example) design
%
\usepackage{listings}
\newcounter{ipythoncounter}
\setcounter{ipythoncounter}{1}

\renewcommand{\ttdefault}{pcr}
\lstset{
  aboveskip=\bigskipamount,
  belowskip=\bigskipamount,
  basicstyle=\footnotesize\ttfamily,
  language=Python,
  numbers=left,
  stepnumber=9999,
  numberfirstline=true,
  xleftmargin=2cm,
}

\lstnewenvironment{ipythoninput}
                  {
                    \setcounter{lstnumber}{\value{ipythoncounter}}
%                    \renewcommand{\thelstnumber}
%                                 {\bf\ttfamily In [\the\value{lstnumber}]:}
                    \renewcommand{\thelstnumber}
                                 {\bf\ttfamily In [\the\value{ipythoncounter}]:}
                    \lstset{
                      frame=single,
                      frameround=tttt,
                      name=ipythoninput,
                    }
                  }
                  {
                    \addtocounter{ipythoncounter}{1}
                  }

\lstnewenvironment{ipythonoutput}
                  {
                    \addtocounter{ipythoncounter}{-1}
                    \setcounter{lstnumber}{\value{ipythoncounter}}
                    \renewcommand{\thelstnumber}
                                 {\bf\ttfamily Out[\the\value{ipythoncounter}]:}
                    \lstset{
                      name=ipythoninput
                    }
                  }
                  {
                    \addtocounter{ipythoncounter}{1}
                  }

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}

\theoremstyle{definition}
\newtheorem{example}[theorem]{Example}


\DeclareMathOperator{\ZZ}{\mathbb{Z}}
\DeclareMathOperator{\RR}{\mathbb{R}}
\DeclareMathOperator{\CC}{\mathbb{C}}
\DeclareMathOperator{\hg}{\mathfrak{h}_g}
%% \DeclareMathOperator{\dx}{dx}
%% \DeclareMathOperator{\dt}{dt}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\dt}{\,\mathrm{d}t}
\DeclareMathOperator{\DivC}{\mathcal{C}}
\DeclareMathOperator{\DivD}{\mathcal{D}}
\DeclareMathOperator{\RCV}{\boldsymbol{K}}
\DeclareMathOperator{\Abel}{\boldsymbol{A}}
\DeclareMathOperator{\HalfLattice}{\Lambda_{1/2}}

\newcommand{\thchar}[2] {\begin{bmatrix}#1\\#2\end{bmatrix}}
\newcommand{\thcharsm}[2] {\left[ \begin{smallmatrix} #1
      \\ #2 \end{smallmatrix} \right]}


\title{Computing the Riemann Constant Vector}
\author{
  \centering
  \footnotesize
  \begin{tabular}{ccc}
    % names
    Bernard Deconinck &
    Matthew Patterson &
    Chris Swierczewski \\
    % address 1
    University of Washington &
    (Matt's Address) &
    University of Washington \\
    % address 2
    Department of Applied Mathematics &
    (Matt's Address) &
    Department of Applied Mathematics \\
    % address 3
    Seattle, WA 98195-3925 &
    (Matt's Address) &
    Seattle, WA 98195-3925 \\
    % email
    \href{mailto:bernard@uw.edu}{\tt bernard@uw.edu} &
    \href{mailto:matt@patterson.com}{\tt matt@patterson.com} &
    \href{mailto:cswiercz@uw.edu}{\tt cswiercz@uw.edu}
  \end{tabular}
}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\begin{abstract}
The Riemann constant vector is a fundamental ingredient in the study of
Riemann surfaces and their Jacobians. It appears in many applications
including the Jacobi inversion problem, the study of the theta divisor,
and solutions to integrable partial differential equations.

We present a mathematical algorithm and an implementation for computing
the vector of Riemann constants on a Riemann surface given by the
desingularization and compactification of a complex algebraic curve. The
implementation and source code is provided in the Python software
package {\sc abelfunctions}.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\it Paragraph: answer the following
\begin{itemize}
  \item What is the problem?

    Compute the Riemann constant vector for arbitrary complex plane
    curves at arbitrary places.

  \item Why is this problem important?

    RCV occurs in periodic solutions to nonlinear integrable PDEs.  A
    fundamental property of Riemann surfaces.  Primary ingredient, along
    with theta, in computing Abelian functions.

  \item What has been done for far on the problem?

    Maple implementation by Matt Patterson.  Other attempts?
    Hyperelliptic solution?  Check Fay’s thesis, Baker.

  \item What is the main contribution of the paper to the problem?

    Emphasize that it’s for a general case surface. Provide a
    step-by-step, realizable mathematical algorithm. Provide and
    describe the current implementation.

  \item Why is the contribution original?

    (literature review) Probably only done for hyperelliptic case. (?)

  \item Why is the contribution non-trivial?

    Again, general case.
\end{itemize}
}

The primary contribution of this paper is to provide an abstract
algorithm and software implementation for computing the Riemann Constant
Vector for an arbitrary Riemann surface given by the desingularization
and compactifications of a complex plane curve. An implementation of the
algorithms described in this paper is given in {\sc abelfunctions}, an
open--source Python library. The implementation details can be freely
examined in the source code at
\verb=www.github.com/cswiercz/abelfunctions=. Software documentation,
including installation and use instructions, is located at
\verb=abelfunctions.cswiercz.info=.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Definitions and Background}\label{sec:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% %------------------------------------------------------------------------------
%% \subsection{Riemann Surfaces}
%% %------------------------------------------------------------------------------


Let $C$ be a complex plane algebraic curve $C = \{(\alpha,\beta) \in
\CC^2 : f(\alpha,\beta) = 0\}$ where $f \in \CC[x,y]$ is a polynomial
$f(x,y) = \sum_{k=0}^n a_k(x) y^k$. Let $X$ be the genus $g$ compact and
connected Riemann surface obtained by desingularizing and compactifying
the curve $C$. Every compact and connected Riemann surface can be
obtained in this way \cite{Griffiths89}.

The first homology group $H_1(X,\ZZ)$ of $X$ is the collection of all
cycles on $X$ modulo homologous transformations. $H_1(X,\ZZ)$ has a
canonical basis of cycles $\{a_1,\ldots,a_g,b_1,\ldots,b_g\}$. The space
of holomorphic 1-forms $\Gamma(X,\Omega_X^1)$ on $X$ is the collection
of all 1-forms $\omega \in \Omega_X^1$ such that for each local
coordinate $z_\alpha : U_\alpha \subset X \to \CC$,
\begin{equation}
  \omega \big|_{U_\alpha}  = h_\alpha(z_\alpha) dz_\alpha
\end{equation}
where $h_\alpha : U_\alpha \to \CC$ is a holomorphic
function. $\Gamma(X,\Omega_X^1)$ has a basis of holomorphic one-forms
$\{\omega_1, \ldots, \omega_g\}$.

We define the Jacobian of $X$, $J(X)$ using these two
ingredients. Construct the {\it period matrix} $\tau = [A \; B]$ of $X$
where
\begin{gather} \label{eqn:periodmatrix}
  A = (A_{ij})_{i,j=1}^g, \quad A_{ij} = \oint_{a_j} \omega_i, \notag \\
  B = (B_{ij})_{i,j=1}^g, \quad B_{ij} = \oint_{b_j} \omega_i.
\end{gather}
We choose to normalize the one-forms $\omega_i$ such that $A = I_{g
  \times g}$, the $g \times g$ identity matrix, resulting in the period
matrix $\tau = [I_{g \times g} \; \Omega]$. By the Riemann bilinear
relations this is equivalent to setting $\Omega = A^{-1}B$. The matrix
$\Omega$ is a {\it Riemann matrix}: a symmetric complex $g \times g$
matrix with positive definite imaginary part. See [XXX] for more
information on period matrices of Riemann surfaces and their
Jacobians. An algorithm for computing Riemann matrices are described in
\cite{DeconinckPatterson08}.

%% \begin{example}
%%   {\it (Include computational example of homology, one-forms, and period
%%     matrix.)}
%% \end{example}



%------------------------------------------------------------------------------
\subsection{Places and Divisors}
%------------------------------------------------------------------------------



Given a place $P \in X$ a local representation of the Riemann surface
centered at $P$ can be given using Puiseux series [XXX].
\begin{definition}\label{def:puiseux}
Given a local parameter $t$ a Puiseux series is given by
\begin{align} \label{eqn:puiseux}
  P =
  \begin{cases}
    x_P(t) = \alpha + \lambda t^e, \\
    y_P(t) = \sum_{k=0}^\infty \beta_k t^{n_k},
  \end{cases}
\end{align}
where $\alpha, \lambda, \beta_k \in \CC$, and $e, n_k \in \ZZ$.
\end{definition}
\noindent Places lie ``above'' the curve $C$ in the sense that
evaluating $P = (x_P(t), y_P(t))$ at $t=0$ maps the place $P$ to point
$(\alpha,\beta)$ on the curve $C$. A place is called {\it discriminant}
or {\it singular} if it lies above a discriminant point of
$C$. Otherwise, it is {\it regular}.

\begin{example}
  {\it Include computational example of places.}

  Let $X$ be the Riemann surface obtained from the curve $C: f(x,y) =
  [XXX] = 0$. There are [XXX] places on $X$ lying above $C$ where
  $x_P(0) = 0$.
  \begin{align}
    P_0 =
    \begin{cases}
      x_{P_0}(t) = [XXX] \\
      y_{P_0}(t) = [XXX],
    \end{cases} \notag \\
    P_1 =
    \begin{cases}
      x_{P_1}(t) = [XXX] \\
      y_{P_1}(t) = [XXX].
    \end{cases}
  \end{align}

  Using {\sc abelfunctions} we can compute places on $X$:

\begin{ipythoninput}
from abelfunctions import *
from sympy.abc import x,y

f = ...
X = RiemannSurface(f,x,y)
places_above_zero = X(0)
for P in places_above_zero:
    print P
    print
\end{ipythoninput}
\begin{ipythonoutput}
x(t) = ...
y(t) = ...

x(t) = ...
y(t) = ...
\end{ipythonoutput}

  We can verify that these places map to points on the curve:

\begin{ipythoninput}
for P in places_above_zero:
    alpha,beta = P(0)
    print f.subs({x:alpha, y:beta})
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
[XXX]
\end{ipythonoutput}

\end{example}

Related to places is the notion of a divisor.
\begin{definition} \label{def:divisor}
A divisor $\DivD$ on the Riemann surface $X$ is a finite formal linear
combination of places $P_i$ with multiplicities $n_i$
\begin{equation}
\DivD = \sum_i n_i P_i.
\end{equation}
The sum
\begin{equation}
\deg \DivD = \sum_i n_i
\end{equation}
is called the degree of $\DivD$.
\end{definition}
The set of all divisors forms an Abelian group $\text{Div}(X)$ under
addition. A divisor with all $n_i \geq 0$ is called {\it positive} or
{\it effective}. A {\it valuation divisor}, important to the calculation
of the Riemann constant vector, is obtained by examining the root and
pole structure of a meromorphic one-form on $X$.
\begin{definition} \label{def:valuationdivisor}
Let $\nu \in \Omega_X^1$ with zeros of multiplicities $p_j$ at the
places $P_j$ and poles of multiplicities $q_j$ at the places $Q_j$. Then
\begin{equation} \label{eqn: valuation divisor}
  (\nu)_\text{val} = \sum_{i=1}^m p_iP_i - \sum_{j=1}^n q_jQ_j
\end{equation}
is called the valuation divisor of $\nu$.
\end{definition}
A divisor $\DivC \in \text{Div}(X)$ is called {\it canonical} if $\DivC
= (\nu)_\text{val}$ for some meromorphic one-form $\nu$ on $X$. All
canonical divisors have the same degree and, by the Riemann--Roch
theorem, this degree is $\deg \DivC = 2g - 2$ [XXX]. Note that every
{\it holomorphic} one-form is trivially meromorphic and its valuation
divisor has $q_j = 0$ for all $j$. Consequently, every holomorphic
one-form has exactly $2g-2$ zeros including multiplicities.


\begin{example}
  {\it (Include computational example of Divisors.)}
\begin{ipythoninput}
D = sum(places_over_zero)
print D
print D.degree()
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}
\begin{ipythoninput}
print D
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}

\end{example}


%------------------------------------------------------------------------------
\subsection{The Abel Map}
%------------------------------------------------------------------------------

%% The Abel map is a fundamental map from a Riemann surface $X$ to its
%% Jacobian $J(X)$.

\begin{definition}\label{def:abelmap}
  Let $P \in X$ be a fixed place. The Abel Map $\boldsymbol{A} : X \to
  J(X)$ is defined
  \begin{equation} \label{eqn:abel1}
    \boldsymbol{A}(P,Q) = \big( A_1(P,Q), \ldots, A_g(P,Q) \big),
  \end{equation}
  where
  \begin{equation} \label{eqn:abel2}
    A_j(P,Q) = \int_P^Q \omega_j,
  \end{equation}
  the path chosen from $P$ to $Q$ is the same for each $A_j$, and
  $\boldsymbol{\omega} = (\omega_1,\ldots,\omega_g)$ is the normalized
  basis of holomorphic one-forms. The Abel map can be written in vector
  form as
  \begin{equation} \label{eqn:abel-vector}
    \boldsymbol{A}(P,Q) = \int_P^Q \boldsymbol{\omega}.
  \end{equation}
\end{definition}
The definition of the Abel map can be extended to divisors: let $\DivD =
\sum_i n_i P_i$. We define
\begin{equation} \label{eqn:abel-divisors}
  \boldsymbol{A}(P,\DivD) = \sum_i n_i \boldsymbol{A}(P,P_i).
\end{equation}
The Abel Map is independent of the path $\gamma$ from $P$ to $Q$ chosen
on $X$ for if $\gamma$ and $\eta$ are two such paths then their
difference is a linear combination of homology basis cycles. The
integral of $\boldsymbol{\omega}$ along this closed path is a lattice
element and therefore is congruent to zero in $J(X)$.

An algorithm for computing the Abel map is described in
\cite{DeconinckPatterson11}. The implementation in {\sc abelfunctions}
is based on this algorithm.

\begin{example}
  {\it (Include computational example of Abel Map.)}

\begin{ipythoninput}
J = X.jacobian()
P = places_above_zero[0]
Q = places_above_zero[1]

print Abel(P,Q)

z1 = Abel(P)
z2 = Abel(Q)
print J(z2 - z1)
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}

\end{example}



%------------------------------------------------------------------------------
\subsection{Riemann Constant Vector}
%------------------------------------------------------------------------------

%% We finally arrive at the definition of the subject of this paper.

\begin{definition} \label{def:rcv}
Let $X$ be a genus $g$ Riemann surface with associated Riemann matrix
$\Omega$. The Riemann constant vector $\RCV : X \to J(X)$ is defined as
\begin{equation} \label{eqn:rcv1}
  \RCV(P) = \big( K_1(P), \ldots, K_g(P) \big),
\end{equation}
where
\begin{equation} \label{eqn:rcv2}
  K_j(P) = \frac{1 + \Omega_{jj}}{2} - \sum_{k \neq j}^g
           \oint_{a_k} \omega_k(Q) A_j(P,Q).
\end{equation}
\end{definition}
Once we know the value of $\RCV(P_0)$ the value of $\RCV(P)$ can be
determined using only a shift by the Abel map:
\begin{theorem} \label{thm:RCVshift}
  Let $P_0,P$ be places on a genus $g$ Riemann surface $X$. Then
  \begin{equation} \label{eqn:RCVshift}
    \RCV(P) = \RCV(P_0) + (g-1)\Abel(P_0,P).
  \end{equation}
\end{theorem}
\begin{proof}
Let $Q$ be an arbitrary place on $X$. By the definition of the Abel map,
$\Abel(P,Q) = \Abel(P,P_0) + \Abel(P_0,Q)$. Using this identity in the
definition of the RCV we obtain
\begin{align} \label{eqn:RCVshift1}
  K_j(P)
  &=
  \frac{1 + \Omega_{jj}}{2}
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) A_j(P,Q)  \notag \\
  &=
  \frac{1 + \Omega_{jj}}{2}
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) \Big( A_j(P,P_0) + A_j(P_0,Q) \Big)  \notag \\
  &=
  \frac{1 + \Omega_{jj}}{2}
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) A_j(P,P_0)
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) A_j(P_0,Q).
\end{align}
The $j$th-component of the Abel map appearing in the first sum has no
dependence on the variable of integration $Q$. Therefore,
\begin{align} \label{eqn:RCVshift2}
  K_j(P)
  &=
  \frac{1 + \Omega_{jj}}{2}
  -
  \sum_{k \neq j}^g
  A_j(P,P_0)
  \oint_{a_k} \omega_k(Q)
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) A_j(P_0,Q) \notag \\
  &=
  \frac{1 + \Omega_{jj}}{2}
  -
  (g-1) A_j(P,P_0)
  -
  \sum_{k \neq j}^g
  \oint_{a_k} \omega_k(Q) A_j(P_0,Q) \notag \\
  &=
  K_j(P_0) + (g-1)A_j(P_0,P).
\end{align}
\end{proof}
The primary computational benefit to using the result of Theorem
\ref{thm:RCVshift} is that most of the work in evaluating $\RCV$ comes
from evaluating it at a fixed place $P_0$. Once this is done, we only
need the Abel map to determine $\RCV$ for all other places $P \in X$. In
{\sc abelfunctions} a fixed place of the Riemann surface is
automatically chosen.

The inspiration behind the algorithm for computing the RCV described in
the following section comes from the following two theorems. Theorem
\ref{thm:rcvequiv} characterizes a certain class of divisors in terms of
the RCV, a proof of which can be found in \cite{FarkasKra92}[XXX].
\begin{theorem} \label{thm:rcvequiv}
  Let $\DivC$ be a divisor on a genus $g$ Riemann surface $X$ of degree
  $2g - 2$. Then $\DivC$ is a divisor of a meromorphic one-form $\nu \in
  \Omega_X^1$ if and only if
  \begin{equation} \label{eqn:rcvequiv}
    2\RCV(P) \equiv -\Abel(P,\DivC).
  \end{equation}
\end{theorem}
\noindent Theorem \ref{thm:thetadivisor} establishes a connection
between the Riemann theta function and the RCV, a proof of which can be
found in [XXX].
\begin{definition} \label{def:riemanntheta}
  The Riemann theta function $\theta: J(X) \times \hg \to \CC$ is
  defined
  \begin{equation} \label{eqn:riemanntheta}
    \theta(z,\Omega)
    =
    \sum_{n \in \ZZ^g}
    e^{2 \pi i \left( \tfrac{1}{2} n \cdot \Omega n + n \cdot z \right)}.
  \end{equation}
  This function converges absolutely and uniformly on compact sets in
  $J(X) \times \hg$ where $\hg$ is the space of all Riemann matrices.
\end{definition}

\begin{theorem} \label{thm:thetadivisor}
  Let $\Omega$ be the Riemann matrix associated with the Riemann surface
  $X$ and $P_0 \in X$ an arbitrary place. Then a vector $\boldsymbol{W}
  \in J(X)$ satisfies
  \begin{equation} \label{eqn:thetadivisor1}
    \theta(\boldsymbol{W}, \Omega) = 0
  \end{equation}
  if and only if there exists a divisor $\DivD = P_1 + \cdots P_{g-1}$
  such that
  \begin{equation} \label{eqn:thetadivisor2}
    \boldsymbol{W} = \boldsymbol{A}(P_0, \DivD) + \boldsymbol{K}(P_0).
  \end{equation}
\end{theorem}
Note that $\DivD$ may contain a place of multiplicity greater than
one. The primary requirement of $\DivD$ is that it is of degree $g-1$
and is effective. The set $\Theta := \{ \boldsymbol{W} \in J(X) :
\theta(\boldsymbol{W},\Omega) = 0\}$ is known as the {\it theta divisor}
of the Riemann surface $X$. It is a $(g-1)$ complex--dimensional
subvariety of $J(X)$. Theorem \ref{thm:thetadivisor} states that $\Theta
= \Abel\left(P_0,SX^{g-1}\right) + \boldsymbol{K}(P_0)$ where $SX^{g-1}$
is the $(g-1)$--fold symmetric product of the Riemann surface.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing the Riemann Constant Vector}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





In this section we present an abstract algorithm for computing the
Riemann constant vector and a demonstration of its implementation in the
Python library {\sc abelfunctions}. We first present an overview of and
motivation behind the algorithm and describe the two primary components
of the algorithm later in this section.

Theorem \ref{thm:rcvequiv} suggests an approach to computing the RCV
provided we can compute a canonical divisor of the Riemann
surface. However, even with such a divisor the theorem only makes a
statement about the value of $2\RCV(P_0)$. That is, one would like to
say
\begin{equation}
\RCV(P_0) \equiv - \tfrac{1}{2} \Abel(P_0,\DivC)
\end{equation}
but division is not unique modulo the lattice $\Lambda$. In general,
there are $2^{2g}$ {\it ``half-lattice vectors''} $\boldsymbol{h} \in
\tfrac{1}{2}\Lambda$ such that $\RCV(P_0) \equiv \boldsymbol{h} -
\tfrac{1}{2}\Abel(P_0,\DivC)$. Therefore, a second objective is to find
an approriate half-lattice vector.

\begin{algorithm}[H]
\caption{\tt riemann\_constant\_vector}
\label{alg:rcv}
\begin{algorithmic}[1]
  \Require Riemann surface $X$ given by the desingularization and
  compactification of complex plane curve $C : f(x,y) = 0$

  \Require place $P \in X$

  \Ensure Riemann constant vector $\RCV(P)$

  \State compute the Riemann matrix $\Omega$

  \State $\DivC \gets$ \verb=canonical_divisor()=
  \Comment{Algorithm \ref{alg:canonical}}

  \State $\boldsymbol{h} \gets$ \verb=half_lattice_vector()=
  \Comment{Algorithm \ref{alg:half-lattice-vector}}

  \State $\RCV_0 \gets \left[ \left[ \boldsymbol{h} -
      \tfrac{1}{2}\Abel(P_0,\DivC) \right] \right]$

  \For{$j = 1,\ldots,g$}

      \State $K_j \gets \tfrac{1}{2}(1+\Omega_{jj}) + (g-1)A_j(P_0,P) -
      (\RCV_0)_j$

  \EndFor

  \State \Return $\RCV = (K_1, \ldots, K_g)$
\end{algorithmic}
\end{algorithm}

The rest of this section presents in detail the subroutines
\verb=canconical_divisor= and \verb=half_lattice_vector= which provide
the necessary remaining ingredients for the above algorithm.



%------------------------------------------------------------------------------
\subsection{Computing a Canonical Divisor}\label{sec:canonical}
%------------------------------------------------------------------------------



Determining the zeros and poles of a meromorphic one-form
\begin{equation} \label{eqn:meromorphic-one-form}
\nu = \frac{p(x,y)}{q(x,y)}\dx
\end{equation}
is not as straightforward as finding the roots of the polynomials $p$
and $q$. One challenge comes from analyzing the local behavior of
$\dx$. Furthermore, it may occur that the numerator and denominator have
the same order of vanishing at some place $P \in X$ in which case $P$ is
neither a root nor pole of $\nu$.

A necessary condition for a place $P \in X$ to be a root or pole of
$\nu$ is that
\begin{equation}
  p\big(x_P(0), y_P(0)\big) = 0,
  \quad
  q\big(x_P(0), y_P(0)\big) = 0,
  \quad \text{or} \quad
  \frac{dx_P}{dt}(0) = 0.
\end{equation}
Consider the resultant $R(x) := R(f,p)(x)$ with respect to $y$. By
definition, the roots of $R$ are the points $\alpha \in \CC_x$ such that
\begin{equation}
f(\alpha,y) = 0 \quad \text{and} \quad p(\alpha, y) = 0
\end{equation}
have simultaneous solutions. Therefore, it is necessary that any place
$P \in X$ where $p$ vanishes it must be the case that $x_P(0)$ is a root
of $R$.

We determine the sets
\begin{align}
\mathcal{X}_\nu^{(1)} &=
\left\{
\alpha \in \CC_x \; | \; R(f,p)(\alpha) = 0
\right\}, \notag \\
\mathcal{X}_\nu^{(2)} &=
\left\{
\alpha \in \CC_x \; | \; R(f,q)(\alpha) = 0
\right\}, \quad \text{and} \notag \\
\mathcal{X}_\nu^{(3)} &=
\left\{
\alpha \in \CC_x \; | \; \alpha \text{ is a branch point of $f$}
\right\}.
\end{align}
containing the $x$-projections of the places $P$ where $p$ or $q$ may
vanish on $X$ as well as those where $(dx_P/dt)(0) = 0$. Since the
representation in Equation \ref{eqn:meromorphic-one-form} only captures
the affine behavior of the meromorphic one-form we need to add the point
at infinity as a point to check. Thus, the set of all $x$-points we need
to consider is
\begin{equation}
\mathcal{X}_\nu
=
\mathcal{X}_\nu^{(1)} \cup
\mathcal{X}_\nu^{(2)} \cup
\mathcal{X}_\nu^{(3)} \cup
\{ \infty \}.
\end{equation}
The Puiseux algorithm is designed to return the corresponding places
\begin{equation}
\mathcal{P}_\nu =
\left\{ P \in X \; | \; x_P(0) \in \mathcal{X}_\nu
\right\}.
\end{equation}

Again, the set $\mathcal{P}_\nu$ necessarily contains the zeros and
poles of $\nu$. For each place $P \in \mathcal{P}_\nu$ we now need to
determine if $P \in (\nu)_\text{val}$. We do so by substituting the
Puiseux series representation $x=x_P(t), y=y_P(t)$ into $\nu$ to obtain
\begin{equation} \label{eqn:localization}
\nu \big|_P
=
\frac{p\big(x_P(t),y_P(t)\big)}{q\big(x_P(t),y_P(t)\big)} \dx(t)
=
\frac{p(t)}{q(t)} x'(t) \dt,
\end{equation}
which gives us the local behavior of $\omega$ on $X$ at $P$. Then, we
rewrite Equation \ref{eqn:localization} as a Laurent series
\begin{equation}
\nu \big|_P = \left( c t^{\text{val}(\nu,P)} + \cdots \right) \dt
\end{equation}
where $\text{val}(\nu,P)$ is the leading order behavior of $\omega$ at
$P$. This gives us sufficient information to determine the root or pole
structure of $\nu$: if $\text{val}(\nu,P) < 0$ then $P$ is a pole, if
$\text{val}(\nu,P) > 0$ then $P$ is a zero, otherwise $P$ does not
appear in the valuation divisor for $\nu$.

This proceedure is simplified when computing the valuation divisor of
holomorphic one-forms. Since every holomorphic one-form is trivially
meromorphic we will use one of the basis elements $\{\omega_1, \ldots,
\omega_g\}$ of $\Gamma(X,\Omega_X^1)$ to obtain a canonical divisor on
$X$. This is done for several performance--related reasons.
\begin{itemize}
\item We already compute these one-forms for the purposes of determining
  the period matrix of $X$ as well as in defining the Abel map.
\item Fewer resolvent sets need to be determined. The denominator of
  every holomorphic one-form is $\partial_y f(x,y)$ so one can compute
  the resolvent set of $f$ with $\partial_y f$ once and use the results
  for each holomorphic one-form. This particular resolvent set consists
  of the discriminant points of $f$ and is already used in the period
  matrix calculations [XXX].
\item The set of $P$ such that $x_P(0)$ is a branch point of $f$ is
  contained in the set of discriminant points of $f$. Therefore, the set
  $\mathcal{X}_\omega^{(3)}$ is a redendant calculation and can be
  skipped.
\item In general, the valuation divisors of holomorphic one-forms
  consist of fewer distinct places. The degree of every canonical
  divisor is $2g-2$. Therefore, there must always be $2g-2$ more zeros
  than poles, counting multiplicities. So to minimize the number of
  places to check we choose to use holomorphic one-forms.
\item By using holomorphic one-forms we can stop computing places in
  $\DivC$ the moment $\deg \DivC = 2g-2$. Because of this, we
  distinguish between the set of $x$-points $\mathcal{X}_\omega$ and
  corresponding places $\mathcal{P}_\omega$ and only compute Puiseux
  series and localize $\omega$ when necessary.
\end{itemize}

An abstract algorithm for computing the valuation divisor of a
holomorphic one-form is given here.
\begin{algorithm}[H]
\caption{{\tt canonical\_divisor} - canonical divisor of a Riemann surface}
\label{alg:canonical}
\begin{algorithmic}[1]
  \Require Riemann surface $X$ given by the desingularization and
  compactification of complex plane curve $C : f(x,y) = 0$

  \Require holomorphic one-form $\omega = p(x,y) / \partial_y f(x,y)
  \dx$ on $X$

  \Ensure canonical divisor $\DivC = (\omega)_\text{val}$

  \State $\DivC \gets$ zero divisor

  \State $\mathcal{X}_\omega^{(1)} \gets$ roots of resolvent $R(f,p)(x)
  = 0$

  \State $\mathcal{X}_\omega^{(2)} \gets$ discriminant points of $f$

  \State $\mathcal{X}_\omega \gets \mathcal{X}_\omega^{(1)} \cup
  \mathcal{X}_\omega^{(2)} \cup \{ \infty \}$

  \For{$\alpha \in \mathcal{X}_\omega$}

  \State $\mathcal{P}_\omega^\alpha \gets \left\{ P \in X \; | \; x_P(0)
  = \alpha \right\}$

  \For{$P \in \mathcal{P}_\omega^\alpha$}

  \State $n \gets \text{val}\left(\omega,P\right)$

  \State $\DivC \gets \DivC + \,n P$

  \If{$\deg \DivC = 2g - 2$}
  \State \Return $\DivC$
  \EndIf

  \EndFor

  \EndFor

  \State {\bf raise error}(``Not enough places found.'')

\end{algorithmic}
\end{algorithm}

Some notes about the algorithm:
\begin{itemize}
\item Only the leading order behavior of the Puiseux series
  parameterizations of each place $P \in \mathcal{P}_\omega^\alpha$ to
  determine $\text{val}(\omega,P)$ is needed implying that computing
  only the ``singular part'' of these expansions using the method of
  Duval is sufficient [XXX].
\item Since we only need a canonical divisor we can chose the
  holomorphic differential basis element $\omega_i$ with lowest total
  degree numerator $p=p(x,y)$ to reduce the size of
  $\mathcal{X}_\nu^{(1)}$ and therefore possibly the number of places to
  check.
\item Algorithm \ref{alg:canonical} will terminate once the target
  degree is met and not spend any further computational effort computing
  places and valuations. A significant gain in efficiency is observed
  when the set $\mathcal{X}_\omega$ is ordered such that places over
  $x,y \in \{0,\infty\}$ are checked first. For resting purposes, the
  algorithm can be modified to verify that $\text{val}(\omega,P) = 0$
  for all remaining $P\in \mathcal{P}_\omega$.
\item If the main loop in Algorithm \ref{alg:canonical} terminates
  before the requisite degree is achieved then an error is
  reported. This is included as a sanity check for the algorithm. An
  additional test is to verify that $\deg (\omega_i)_\text{val} = 2g-2$
  for all $\omega_i$ basis elements.
\end{itemize}

\begin{example}
  {\it Example canonical divisor computation.}

\begin{ipythoninput}
omega = X.holomorphic_oneforms(normalized=True)
print omega[0]
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}
\begin{ipythoninput}
C = omega[0].valuation_divisor()
for multiplicity, place in C:
    print place
    print

print 'Degree:', C.degree
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}
\end{example}




%------------------------------------------------------------------------------
\subsection{Computing a Half-Lattice Vector}
%------------------------------------------------------------------------------


Now that we have a canonical divisor $\DivC$ what remains is to
determine $\RCV(P_0)$ knowing that $2\RCV(P_0) \equiv - \Abel(P_0,\DivC)
\bmod{\Lambda}$. For now, consider $\RCV(P_0)$ and $\Abel(P_0,\DivC)$ to
be vectors in $\CC^g$ and set $\RCV_0 := \RCV(P_0)$ and $\Abel_0^{\DivC}
:= \Abel(P_0,\DivC)$ for notational convenience. In $\CC^g$ we have
\begin{equation}
2\RCV_0 + \Abel_0^{\DivC} = \boldsymbol{\lambda}
\end{equation}
where $\boldsymbol{\lambda} \in \CC^g$ is unknown and
$\boldsymbol{\lambda} \equiv 0 \bmod{\Lambda}$, meaning that the vector
$\boldsymbol{\lambda}$ is one of the $2^{2g}$ lattice vectors lying in
the fundamental region of $\Lambda$. Division by two is now legal:
setting $\boldsymbol{h} = \boldsymbol{\lambda}/2$ yields
\begin{equation}
\RCV_0 = \boldsymbol{h} - \tfrac{1}{2} \Abel(P_0,\DivC).
\end{equation}
Reducing this expression modulo $\Lambda$ gives the corresponding
equivalence in $J(X)$
\begin{equation}
\RCV_0 \equiv \boldsymbol{h} - \tfrac{1}{2} \Abel(P_0,\DivC)
\bmod{\Lambda}
\end{equation}
where the lattice vector $\boldsymbol{h}$ is unknown.

To determine which of the $2^{2g}$ half-lattice vectors
$\boldsymbol{h}_1, \ldots, \boldsymbol{h}_{2^{2g}}$ is the correct
half-lattice vector we use Theorem \ref{thm:thetadivisor}. The Theorem
requires a degree $g-1$ effective divisor. Consider the divisor
\begin{equation} \label{eqn:simple-effective-divisor}
  \DivD = (g-1)P_0
\end{equation}
where $P_0 \in X$ is the fixed place [XXX]. Then
\begin{align*}
  \theta\big(\Abel(P_0,\DivD) + \RCV(P_0)\big)
  &=
  \theta\bigg(\Abel\big(P_0,(g-1)P_0\big) + \RCV(P_0)\bigg) \notag \\
  &=
  \theta\big(\boldsymbol{0} + \RCV(P_0)\big) \notag \\
  &=
  \theta\big(\RCV(P_0)\big) = 0.
\end{align*}
Therefore, it must be that
\begin{equation}
  \theta\left(
  \boldsymbol{h}_j - \tfrac{1}{2} \Abel(P_0,\DivC)
  \right) = 0
\end{equation}
for {\it at least} of the the $2^{2g}$ half lattice vectors
$\boldsymbol{h}_j$. The choice of divisor above simplifies the
computations. However, any appropriate divisor can be used in conjection
with the Theorem to obtain the RCV.

The idea behind Algorithm \label{alg:half-lattice-vector} is to perform
a number of ``filter passes'' to eliminate incorrect half-lattice
vectors using subroutine in
Algorithm \label{alg:half-lattice-filter}. Each pass uses a different
effective degree $g-1$ divisor beginning with the one defined in
Equation \ref{eqn:simple-effective-divisor}. This heuristic approach is
used due to the numerical approximation inherent in evaluating the
Riemann theta function.

\begin{algorithm}
\caption{{\tt half\_lattice\_vector}$(X,\DivC)$}
\label{alg:half-lattice-vector}
\begin{algorithmic}[1]

\Require a Riemann surface $X$

\Require a canonical divisor $\DivC$

\Ensure a half lattice vector $\boldsymbol{h}$

\State $\mathcal{J} \gets \left\{ 1, \ldots, 2^{2g} \right\}$

\State $\DivD \gets (g-1)P_0$

\State $\mathcal{J} \gets$ {\tt
  half\_lattice\_filter}$(\mathcal{J},\DivC,\DivD)$ \Comment filter pass \#1

\State {\bf if} $\mathcal{J} = \{j^*\}$ {\bf return} $\boldsymbol{h}_{j^*}$

\State $\mathcal{D}_0 \gets P_1 + \cdots P_{g-1}$ where the $P_i$'s are
distinct regular places

\State $\mathcal{J} \gets$ {\tt
  half\_lattice\_filter}$(\mathcal{J},\DivC,\DivD_0)$ \Comment filter pass \#2

\State {\bf if} $\mathcal{J} = \{j^*\}$ {\bf return} $\boldsymbol{h}_{j^*}$

\For{each $m_1, \ldots, m_{g-1} \geq 0$ with $m_1 + \cdots + m_{g-1} =
  g-1$} \Comment filter pass \#3

    \State $\mathcal{D}_k \gets m_1P_1 + \cdots + m_{g-1}P_{g-1}$

    \State $\mathcal{J} \gets$ {\tt
      half\_lattice\_filter}$(\mathcal{J},\DivC,\DivD_k)$

    \State {\bf if} $\mathcal{J} = \{j^*\}$ {\bf return}
    $\boldsymbol{h}_{j^*}$

\EndFor


\State {\bf raise error}(``Could not find appropriate half-lattice vector.'')


\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{{\tt half\_lattice\_filter}$(\mathcal{J},\DivC,\DivD)$}
\label{alg:half-lattice-filter}
\begin{algorithmic}[1]

  \Require index set $\mathcal{J} \subset \{1, \ldots, 2^{2g}\}$

  \Require a canonical divisor $\DivC$

  \Require effective, degree $g-1$ divisor $\DivD$

  \Ensure filtered index set $\tilde{\mathcal{J}}$

  \State $\tilde{\mathcal{J}} \gets \mathcal{J}$

  \State $\theta( \cdot, \Omega) \gets$ the Riemann theta function
  uniformly accurate to order $\epsilon$

  \State $\boldsymbol{Z} \gets \Abel(P_0,\DivD) - \tfrac{1}{2}
  \Abel(P_0,\DivC)$

  \For{$j \in \mathcal{J}$}

      \State $\boldsymbol{\kappa}_j \gets \boldsymbol{h}_j - \boldsymbol{Z}
      \bmod{\Lambda}$

      \If{$|| \theta(\boldsymbol{\kappa}_j) || > \epsilon$}

          \State remove $j$ from $\tilde{\mathcal{J}}$

      \EndIf

  \EndFor

  \State \Return $\tilde{\mathcal{J}}$

\end{algorithmic}
\end{algorithm}

Some notes on Algorithms \ref{alg:half-lattice-vector} and
\ref{alg:half-lattice-filter}:
\begin{itemize}
  \item If a candidate vector $\boldsymbol{\kappa}_j \in J(X)$ is, in
    fact, the sought-after vector such that
    $\theta(\boldsymbol{\kappa}_j) = 0$ then it must be so for all
    effective degree $g-1$ divisors $\DivD$. That is, every perturbation
    must also be such that
    \begin{equation}
      \theta\big(\boldsymbol{\kappa}_j + \Abel(P_0,\DivD)\big) = 0.
    \end{equation}
    This can be used for additional verification of our results.
  \item Care must be used when setting the numerical accuracy of the
    Riemann theta function. In {\tt abelfuncitons}, the default accuracy
    of $\epsilon = 1e-8$ may be insufficient for finding a unique
    solution. All numerical computations are performed using native
    double precision so one must not set $\epsilon$ too close to $1e-16$
    or else numerical round-off error may affect results as well.
\end{itemize}


\begin{example}
  {\it Example half-lattice vector and RCV computation.}

\begin{ipythoninput}
h = half_lattice_vector(...)
print h
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}
\begin{ipythoninput}
K = RiemannConstantVector(...)
\end{ipythoninput}
\begin{ipythonoutput}
[XXX]
\end{ipythonoutput}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
  \item foo
  \item bar
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliographystyle{amsplain}
\bibliography{rcv}

\end{document}

